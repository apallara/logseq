- Gli alberi sono strutture dati derivate dai grafi, in particolare gli alberi sono definiti dalla coppia T=<N,A>. Specificatamente vi sono due insiemi uno per tutti i possibili nodi e uno per tutti i possibili archi generati dal prodotto cartesiano NxN. 
  I nodi sono collegati tra loro per mezzo di archi, in questo caso ogni nodo può avere al più un arco entrante e più archi uscenti. 
  Gli alberi possono essere rappresentati mediante vettore di padri, vettore di figli, liste di figli, lista primofiglio-fratello, lista dinamica, puntatori padre-primofiglio-fratello.
- La realizzazione ((63c14954-6ecd-427d-8b54-f796fd9f36e9)) prevede di utilizzare un vettore pari alla quantità di nodi, per ogni cella è memorizzato il nodo e la posizione del vettore che contiene il padre di quel nodo. Gli svantaggi principali sono quelli legati alla rigidità del vettore. L'operazione di inserimento di un nuovo nodo prevede di collocare il nodo all'interno del vettore e di memorizzare quale è il suo nodo padre, questo con complessità O(2n), visto che vi devono essere 2 scansioni, la prima per collocare il nodo nel vettore, la seconda per trovare il padre di quel nodo. La rimozione prevede complessità O(n) visto che sarà necessario eseguire lo shift degli elementi ancora esistenti. La lettura del padre di un nodo ha costo O(n).
- La realizzazione ((6422e26a-4fc2-4b67-81ed-7bb34a99487d)) prevede di memorizzare ogni nodo memorizzando in un vettore il cursore al padre di quel nodo e nelle altre celle i cursori agli altri eventuali figli di quel nodo. Il problema di questa realizzazione è principalmente quello del vettore che è particolarmente rigido, inoltre la dimensione del vettore è uniforme per tutti i nodi, quindi se fosse necessario memorizzare un nodo che eccede la dimensione del vettore sarà necessario eseguire il doubling di tutti gli altri vettori dei nodi. L'inserimento e la cancellazione richiedono tempo **O(n)??????**.
- La realizzazione ((6422e26a-4920-4276-b76a-f59a2079e2ac)) prevede di istanziare un vettore di dimensione pari alla quantità di nodi dell'albero, per ogni nodo verrà creato un cursore che punta ad una lista contenente tutti i figli di quel nodo, il problema di questa realizzazione è sempre legata alla rigidità del vettore, inoltre risulta complesso ottenere il padre di un dato nodo visto che sarà necessario scandire ogni lista alla ricerca del nodo di interesse, una volta individuato si avrà memorizzato il nodo padre (CC. O(n)). Sapere il primo figlio di un certo padre sarà semplice.
- La realizzazione con ((6422e26a-bcae-4e9a-9e0e-5f7b9892cced)) prevede di utilizzare un cursore al nodo radice e una lista di dimensione pari alla quantità dei nodi, per ogni nodo sarà indicato l'indice della lista dove trovare il fratello di quel nodo e i figli. In questa maniera è semplice trovare il fratello e il primofiglio di un nodo ma trovare il padre di un nodo è complesso visto che bisognerà scandire tutta la lista.
- La realizzazione con ((6422e26a-d0fa-4b20-9a07-8b92686a503a)) prevede di utilizzare per ogni nodo una lista che contiene il valore di quel nodo e il cursore al nodo successivo, se è necessario rappresentare più di un figlio sarà usata una lista ausiliaria.
- La realizzazione ((6422e26a-0d48-4aea-bcf5-55ba3078b7a2)) questa realizzazione prevede di utilizzare liste anzichè array quindi aggirando il problema della loro rigidità. In particolare in questa lista saranno memorizzati il valore del nodo, un cursore al padre, un cursore al fratello e un altro cursore al primofiglio di quel nodo. In questa maniera si ha accesso direttamente a queste informazioni ma nel momento dell'inserimento di un nuovo nodo bisognerà assegnare a tutti i campi i relativi cursori